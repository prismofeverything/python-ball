def list_and(atoms, conditions):
    final = 1

    for ato in atoms:
        for cond in conditions:
            final = cond(ato)
            if not final:
                break
        if not final:
            break

    return final

def list_or(atoms, conditions):
    final = 0

    for ato in atoms:
        for cond in conditions:
            final = cond(ato)
            if final:
                break
        if final:
            break

    return final

letter_conditions = [lambda x: x != '\n',
                     lambda x: x != '\t',
                     lambda x: x != '\ ',
                     lambda x: x > 64,
                     lambda x: x < 123,
                     lambda x: x < 91 or x > 96]





class graph_node:

    def __init__(self, tag, value):
        self.tag = tag
        self.value = value
        self.edges = {}

    def __repr__(self):
        rep = self.tag + ": "
        for edge in edges:
            rep += edge.other(self.tag) + "-" + str(edge.value) + " "
        return rep
        
    def add_edge(self, edge):
        self.edges[edge.other(self.tag)] = edge

    def find_edge(self, othertag):
        if self.edges.has_key(other_tag):
            return self.edges[othertag]
        else return null

    def neighbor_tags(self):
        tags = []
        for edge in self.edges:
            tags.append(edge.other(self.tag).tag)
        return tags

class graph_edge:

    def __init__(self, a, b, value):
        self.nodes = (a, b)
        self.value = value

    def contains_node(tag):
        return tag == self.nodes[0].tag or tag == self.nodes[1].tag

    def other(tag):
        if tag == self.nodes[0].tag:
            return self.nodes[1]
        else:
            return self.nodes[0]

class graph:

    def __init__(self):
        self.nodes = {}

    def __repr__(self):
        rep = ""
        for node in nodes:
            rep += str(node) + "\n"
        return rep

    def add_node(self, node):
        self.nodes[node.tag] = node

    def contains_node(self, tag):
        if self.nodes[tag]:
            return 1
        else:
            return 0

    def connect(self, pair):
        anode = self.nodes[pair[0]]
        bnode = self.nodes[pair[1]]
        
        edge = node_edge(anode, bnode, 0)

        anode.add_edge(edge)
        bnode.add_edge(edge)

        return edge

    def find_edge(pair):
        anode = self.nodes[pair[0]]
        if anode:
            return anode.find_edge(pair[1])
        else:
            return anode



class letter_graph(graph):
    def __init__(self):
        graph.__init__(self)
        
    def letter_pair(self, pair):

        if not self.nodes.has_key(pair[0]):
            self.add_node(pair[0], 0)
            
        if not self.nodes.has_key(pair[1]):
            self.add_node(pair[1], 0)
            
        edge = self.find_edge(pair)
        if not edge:
            edge = self.connect(pair)

        anode.value += 1
        bnode.value += 1        
        edge.value += 1

        


def graph_pairs(file):
    text = open(file).read()
    graph = letter_graph()
    index = 0

    while index < len(text) - 1:
        a = text[index]
        b = text[index + 1]

        graph.letter_pair((a, b));

    return graph
    

def count_pairs(file):
    text = open(file).read()
    pairs = {}
    index = 0;
    
    while index < len(text) - 1:
        a = text[index]
        b = text[index + 1]

        if list_and([a, b], letter_conditions) and a != b:
            pair = '' + a.lower() + b.lower()

            if not pairs.has_key(pair):
                pairs[pair] = 0

            pairs[pair] += 1

        index += 1

    return pairs

def swap(ls, a, b):
    c = ls[a]
    ls[a] = ls[b]
    ls[b] = c

def sort_pairs(pairs):
    unsorted = pairs.items()
    sorted = []

    for pair in unsorted:
        balanced = 0
        pair_index = len(sorted)
        sorted.append(pair)
        pair_frequency = pair[1]

        while not balanced and pair_index > 0:
            sort = sorted[pair_index - 1]
            if pair_frequency > sort[1]:
                swap(sorted, pair_index, pair_index - 1)
                pair_index -= 1
            else:
                balanced = 1

    return sorted

def sort_count(file):
    return sort_pairs(count_pairs(file))

